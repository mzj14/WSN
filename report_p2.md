## 实验二 - 多点协作Data Aggregation实验

### 题目要求

ID为`1000`的节点广播`2000`个数据包给所有节点，每个包的数据字段包含一个`2`个字节的整数，广播完毕后，每组的所有三个节点协作计算这`2000`个数据的`max`、`min`、`sum`、`average`、`median`，最后发送给ID为`0`的节点。

### 计算算法

约定：第`6`组计算节点为`16`号，辅助节点为`17`和`18`号。

1. 数据存储

利用`m_data`数组保存所有收到的`random_integer`，利用`m_flag`数组保存所有收到的`sequence_number`。

由于节点硬件仅有`10K`内存，需要压缩存储空间，故`m_flag`采用位标记的方式压缩存储。

每获取一个新数据（`m_flag`中新有一位被置为1），`m_len`自0开始自增一次，同时自`0`开始扫描`m_flag`中的所有位，更新`m_cont`变量，使得所有第`x`位上的`m_flag`均为1，只要`x < m_cont`。

所有数据均收齐后，`m_cont`和`m_len`值均为2000。

2. 数据交换

令一个计时器`Timer0`在收齐所有数据之前每`20ms`触发一次，下面描述每次触发执行的操作。

首先，如果发送芯片繁忙（`busy`为真），返回。`busy`变量在发送函数调用成功后为真，发送成功调用回调函数时置为假。

由于`1000`号节点广播数据的顺序与`sequence_number`的递增序相同，因此当数据不连续时即判定为丢包，此时有`m_len != m_cont`。

丢包时，计算节点广播所丢`packet`的`sequence_number`，辅助节点响应之，如果辅助节点保存了来自`1000`号广播节点广播过的`sequence_number`号数据，将之返回给计算节点。

由于`m_cont`每收到数据更新一次（见上段尾），下一个计时器事件触发时，如果没有收到想要的数据则重复发送，否则发送下一个补包请求，如果数据均连续，停止。

3. 结果计算

题目要求的所有求解量均可以在`m_data`数组有序的前提下求解，下面描述数组有序性维护。

每获取一个新数据，按插入排序的方式将它插入到`m_data`数组的合理位置，数据集齐后，`m_data`仍然有序。

辅助节点则不进行插入排序，保持`m_data`数据位置与`sequence_number`对应以便返回。

### 实验结果

经测试最好结果为`32s`，约合`1.5`轮，平均结果为`40s`，约合`2`轮。

### 性能瓶颈

1. 由于`m_cont`从`0`开始维护，假设广播节点没有从`sequence_number`为`1`的数据开始发送，或者第一个数据丢包，那么至少等一轮后辅助节点才能收到补包请求。同样的，如果`m_cont`处数据所有辅助节点亦均丢包，仍然需要过完整的至少一轮后才能补其他漏洞。可以尝试分块保存数据连续性信息，或者维护补包队列循环尝试。

2. 未采用分布式算法。

### 实验中遇到的困难

1. 误以为`sequence_number`从`0`开始。

2. 发送数据包没有调用`getPayload`函数，不是`message_t`类型。

3. 最开始没有排除干扰，即调用`source`函数检查收到数据包的发送者`ID`。

### 实验体会

泰山崩于前而色不变，麋鹿兴于左而目不瞬，心静，则天下无`bug`矣。
